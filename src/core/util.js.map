{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"AAYA;;;;GAIG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,IAAY,EAAE,OAA+B,EAAO,EAAE;IAC7E,IAAI,CAAC,OAAO,EAAE,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;IAAC,CAAC;IAC/B,MAAM,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC;IAClD,6EAA6E;IAC7E,IAAI,CAAC,IAAI,EAAE,CAAC;QAAC,OAAO,IAAI,CAAC;IAAC,CAAC;IAC3B,0DAA0D;IAC1D,2FAA2F;IAC3F,MAAM,IAAI,GAAQ,EAAE,CAAC;IACrB,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC;IAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACjG,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC;IAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACjG,iHAAiH;IACjH,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;IACzC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IAC1B,gCAAgC;IAChC,OAAO,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACpC,CAAC,CAAC;AAGF,sGAAsG;AACtG,YAAY;AACZ,sGAAsG;AAEtG,oDAAoD;AACpD,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,IAAY,EAAE,IAA6B,EAAE,IAAU,EAAO,EAAE;IACvF,IAAI,CAAC,IAAI,EAAE,CAAC;QAAC,OAAO;IAAC,CAAC;IAEtB,+CAA+C;IAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACxD,6EAA6E;IAC7E,MAAM,OAAO,GAAG,oBAAoB,MAAM,eAAe,IAAI,UAAU,CAAC;IAExE,IAAI,QAAwC,CAAC;IAE7C,IAAI,CAAC;QACH,4EAA4E;QAC5E,oCAAoC;QACpC,mCAAmC;QACnC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;IAE3B,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QAAC,MAAM,IAAI,KAAK,CAAE,oBAAoB,IAAI,MAAM,CAAC,mBAAmB,OAAO,EAAE,CAAC,CAAC;IAAC,CAAC;IAE9F,IAAI,CAAC;QACH,sCAAsC;QACtC,MAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACnE,uDAAuD;QACvD,OAAO,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,CAAC;IAE7E,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QAAC,MAAM,IAAI,KAAK,CAAE,iBAAiB,IAAI,MAAM,CAAC,mBAAmB,OAAO,EAAE,CAAC,CAAC;IAAC,CAAC;AAE7F,CAAC,CAAC","sourcesContent":["\r\n/** Options to evaluate an expression.\n * ```typescript\n * interface EvalExpressionOptions { host?: any; filterProperties?: string[]; args?: { [key: string]: any }; }\n * ```\n *\n * @param args: Additional arguments to pass to the evaluation function.\n * @param host: Host instance whose properties are exposed as arguments to the evaluation function.\n * @param filterProperties: Filters which host properties will be assigned to arguments. If omitted, all descriptors are traversed.\n */\nexport interface EvalExpressionOptions { host?: any; filterProperties?: string[]; args?: { [key: string]: any } }\n\n/** Evaluates an expression receiving every host property plus any additional `args` as arguments.\n * ```typescript\n * interface EvalExpressionOptions { host?: any; filterProperties?: string[]; args?: { [key: string]: any }; }\n * ```\n */\nexport const evalExpr = (expr: string, options?: EvalExpressionOptions): any => {\n  if (!options) { options = {}; }\n  const filterProperties = options.filterProperties;\n  // Return the expression unchanged when it is: undefined, null, '', 0, false.\n  if (!expr) { return expr; }\n  // Gather all host properties and prototypes as arguments.\n  // options.args = deepAssign(options.args || {}, options.host || {}, { filterProperties });\n  const args: any = {};\n  options.args = options.args || {}; Object.keys(options.args).map(k => args[k] = options.args[k]);\n  options.host = options.host || {}; Object.keys(options.host).map(k => args[k] = options.host[k]);\n  // if (filterProperties !== undefined) { Object.keys(filterProperties).map(k => args[k] = filterProperties[k]); }\n  args.filterProperties = filterProperties;\n  const host = options.host;\n  // Evaluate the expression code.\n  return evalCode(expr, args, host);\n};\n\r\n\r\n// ---------------------------------------------------------------------------------------------------\r\n//  evalCode\r\n// ---------------------------------------------------------------------------------------------------\r\n\r\n/** Utility to execute code supplied as a string. */\nexport const evalCode = (code: string, args?: { [key: string]: any }, host?: any): any => {\n  if (!code) { return; }\n\n  // Get argument names for the wrapper function.\n  const fnArgs = args ? Object.keys(args).join(', ') : '';\n  // Create an object literal with a function to encapsulate the provided code.\n  const wrapper = `({ fn: function (${fnArgs}) { return (${code}); } });`;\n\n  let runnable: { fn: (...args2: any) => any };\n\n  try {\n    // Evaluate the transpiled code to obtain an instance of the wrapper object.\n    // tslint:disable-next-line: no-eval\n    // eslint-disable-next-line no-eval\n    runnable = eval(wrapper);\n\n  } catch (e) { throw new Error (`Evaluating code '${code}'\\n${e}\\n\\n> wrapper:\\n${wrapper}`); }\n\n  try {\n    // Build the array of argument values.\n    const argArray = args ? Object.keys(args).map(k => (args)[k]) : [];\n    // Execute the function passing the provided arguments.\n    return host ? runnable.fn.apply(host, argArray) : runnable.fn(...argArray);\n\n  } catch (e) { throw new Error (`Running code '${code}'\\n${e}\\n\\n> wrapper:\\n${wrapper}`); }\n\n};\n"]}